const std = @import("std");
const microzig = @import("microzig");
const board = microzig.board;
const audio = board.audio;
const timer = microzig.hal.timer;
pub const api = @import("../cart/api.zig");

const libcart = struct {
    extern var cart_data_start: u8;
    extern var cart_data_end: u8;
    extern var cart_bss_start: u8;
    extern var cart_bss_end: u8;
    extern const cart_data_load_start: u8;

    extern fn start() void;
    extern fn update() void;
    extern fn __return_thunk__() noreturn;
};

pub fn svcall_handler() callconv(.Naked) void {
    asm volatile (
        \\ mvns r0, lr, lsl #31 - 2
        \\ bcc 12f
        \\ ite mi
        \\ movmi r1, sp
        \\ mrspl r1, psp
        \\ ldr r2, [r1, #6 * 4]
        \\ subs r2, #2
        \\ ldrb r3, [r2, #1 * 1]
        \\ cmp r3, #0xDF
        \\ bne 12f
        \\ ldrb r3, [r2, #0 * 1]
        \\ cmp r3, #11
        \\ bhi 12f
        \\ tbb [pc, r3]
        \\0:
        \\ .byte (0f - 0b) / 2
        \\ .byte (1f - 0b) / 2
        \\ .byte (2f - 0b) / 2
        \\ .byte (3f - 0b) / 2
        \\ .byte (4f - 0b) / 2
        \\ .byte (5f - 0b) / 2
        \\ .byte (6f - 0b) / 2
        \\ .byte (7f - 0b) / 2
        \\ .byte (8f - 0b) / 2
        \\ .byte (9f - 0b) / 2
        \\ .byte (10f - 0b) / 2
        \\12:
        \\ .byte (11f - 0b) / 2
        \\ .byte 0xDE
        \\ .align 1
        \\0:
        \\ ldm r1, {r0-r3}
        \\ b %[blit:P]
        \\1:
        \\ ldm r1, {r0-r3}
        \\ b %[line:P]
        \\2:
        \\ ldm r1, {r0-r3}
        \\ b %[oval:P]
        \\3:
        \\ ldm r1, {r0-r3}
        \\ b %[rect:P]
        \\4:
        \\ ldm r1, {r0-r3}
        \\ b %[text:P]
        \\5:
        \\ ldm r1, {r0-r3}
        \\ b %[hline:P]
        \\6:
        \\ ldm r1, {r0-r3}
        \\ b %[vline:P]
        \\7:
        \\ ldm r1, {r0-r3}
        \\ b %[tone:P]
        \\8:
        \\ ldm r1, {r0-r2}
        \\ b %[read_flash:P]
        \\9:
        \\ ldm r1, {r0-r1}
        \\ b %[write_flash_page:P]
        \\10:
        \\ ldm r1, {r0-r1}
        \\ b %[trace:P]
        \\11:
        \\ lsrs r0, #31
        \\ msr control, r0
        \\ it eq
        \\ popeq {r3, r5-r11, pc}
        \\ subs r0, #1 - 0xFFFFFFFD
        \\ push {r4-r11, lr}
        \\ movs r4, #0
        \\ movs r5, #0
        \\ movs r6, #0
        \\ movs r7, #0
        \\ mov r8, r4
        \\ mov r9, r5
        \\ mov r10, r6
        \\ mov r11, r7
        \\ bx r0
        :
        : [blit] "X" (&blit),
          [line] "X" (&line),
          [oval] "X" (&oval),
          [rect] "X" (&rect),
          [text] "X" (&text),
          [hline] "X" (&hline),
          [vline] "X" (&vline),
          [tone] "X" (&tone),
          [read_flash] "X" (&read_flash),
          [write_flash_page] "X" (&write_flash_page),
          [trace] "X" (&trace),
    );
}
pub const HSRAM = struct {
    pub const SIZE: usize = 0x00030000; // 192 kB
    pub const ADDR: *align(SIZE / 3) volatile [SIZE]u8 = @ptrFromInt(0x20000000);
};

pub fn start() void {
    @memset(@as(*[0x19A0]u8, @ptrFromInt(0x20000000)), 0);
    api.neopixels.* = .{
        .{ .r = 0, .g = 0, .b = 0 },
        .{ .r = 0, .g = 0, .b = 0 },
        .{ .r = 0, .g = 0, .b = 0 },
        .{ .r = 0, .g = 0, .b = 0 },
        .{ .r = 0, .g = 0, .b = 0 },
    };

    // fill .bss with zeroes
    {
        const bss_start: [*]u8 = @ptrCast(&libcart.cart_bss_start);
        const bss_end: [*]u8 = @ptrCast(&libcart.cart_bss_end);
        const bss_len = @intFromPtr(bss_end) - @intFromPtr(bss_start);

        @memset(bss_start[0..bss_len], 0);
    }

    // load .data from flash
    {
        const data_start: [*]u8 = @ptrCast(&libcart.cart_data_start);
        const data_end: [*]u8 = @ptrCast(&libcart.cart_data_end);
        const data_len = @intFromPtr(data_end) - @intFromPtr(data_start);
        const data_src: [*]const u8 = @ptrCast(&libcart.cart_data_load_start);

        @memcpy(data_start[0..data_len], data_src[0..data_len]);
    }

    call(&libcart.start);
}
pub fn tick() void {
    // TODO: check if frame is ready

    // read gamepad
    //if (SYSTEM_FLAGS.* & SYSTEM_PRESERVE_FRAMEBUFFER == 0) @memset(FRAMEBUFFER, 0b00_00_00_00);
    call(&libcart.update);
}

fn call(func: *const fn () callconv(.C) void) void {
    const process_stack = HSRAM.ADDR[HSRAM.SIZE - @divExact(
        HSRAM.SIZE,
        3 * 2,
    ) ..][0..@divExact(HSRAM.SIZE, 3 * 4)];
    const frame = comptime std.mem.bytesAsSlice(u32, process_stack[process_stack.len - 0x20 ..]);
    @memset(frame[0..5], 0);
    frame[5] = @intFromPtr(&libcart.__return_thunk__);
    frame[6] = @intFromPtr(func);
    frame[7] = 1 << 24;
    asm volatile (
        \\ msr psp, %[process_stack]
        \\ svc #11
        :
        : [process_stack] "r" (frame.ptr),
        : "memory"
    );
}

fn User(comptime T: type) type {
    return extern struct {
        const Self = @This();
        const suffix = switch (@sizeOf(T)) {
            1 => "b",
            2 => "h",
            4 => "",
            else => @compileError("loadUser doesn't support " ++ @typeName(T)),
        };

        unsafe: T,

        pub inline fn load(user: *const Self) T {
            return asm ("ldr" ++ suffix ++ "t %[value], [%[pointer]]"
                : [value] "=r" (-> T),
                : [pointer] "r" (&user.unsafe),
            );
        }

        pub inline fn store(user: *Self, value: T) void {
            asm volatile ("str" ++ suffix ++ "t %[value], [%pointer]]"
                :
                : [value] "r" (value),
                  [pointer] "r" (&user.unsafe),
            );
        }
    };
}

fn blit(
    sprite: [*]const User(u8),
    x: i32,
    y: i32,
    rest: *const extern struct {
        width: User(u32),
        height: User(u32),
        src_x: User(u32),
        src_y: User(u32),
        stride: User(u32),
        flags: User(api.BlitOptions.Flags),
    },
) callconv(.C) void {
    const width = rest.width.load();
    const height = rest.height.load();
    const src_x = rest.src_x.load();
    const src_y = rest.src_y.load();
    const stride = rest.stride.load();
    const flags = rest.flags.load();

    _ = sprite;
    _ = x;
    _ = y;
    _ = width;
    _ = height;
    _ = src_x;
    _ = src_y;
    _ = stride;
    _ = flags;
}

fn line(
    x1: i32,
    y1: i32,
    x2: i32,
    rest: *const extern struct {
        y2: User(i32),
        color: User(api.DisplayColor),
    },
) callconv(.C) void {
    const y2 = rest.y2.load();
    const color = rest.color.load();

    _ = x1;
    _ = y1;
    _ = x2;
    _ = y2;
    _ = color;
}

fn oval(
    x: i32,
    y: i32,
    width: u32,
    rest: *const extern struct {
        height: User(u32),
        stroke_color: User(api.DisplayColor.Optional),
        fill_color: User(api.DisplayColor.Optional),
    },
) callconv(.C) void {
    const height = rest.height.load();
    const stroke_color = rest.stroke_color.load();
    const fill_color = rest.fill_color.load();

    _ = x;
    _ = y;
    _ = width;
    _ = height;
    _ = stroke_color;
    _ = fill_color;
}

fn rect(
    x: i32,
    y: i32,
    width: u32,
    rest: *const extern struct {
        height: User(u32),
        stroke_color: User(api.DisplayColor.Optional),
        fill_color: User(api.DisplayColor.Optional),
    },
) callconv(.C) void {
    const height = rest.height.load();
    const stroke_color = rest.stroke_color.load().unwrap();
    const fill_color = rest.fill_color.load().unwrap();

    if (stroke_color) |sc| {
        hline(x, y, width, sc);
        hline(x, y + @as(i32, @intCast(height)), width + 1, sc);

        vline(x, y, height, sc);
        vline(x + @as(i32, @intCast(width)), y, height, sc);
    }

    if (fill_color) |fc| {
        for (@as(u32, @intCast(y)) + 1..@as(u32, @intCast(y)) + height) |yy| {
            hline(x + 1, @intCast(yy), width - 1, fc);
        }
    }
}

const font = [_]u8{
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xC7, 0xC7, 0xC7, 0xCF, 0xCF, 0xFF, 0xCF, 0xFF,
    0x93, 0x93, 0x93, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x93, 0x01, 0x93, 0x93, 0x93, 0x01, 0x93, 0xFF,
    0xEF, 0x83, 0x2F, 0x83, 0xE9, 0x03, 0xEF, 0xFF,
    0x9D, 0x5B, 0x37, 0xEF, 0xD9, 0xB5, 0x73, 0xFF,
    0x8F, 0x27, 0x27, 0x8F, 0x25, 0x33, 0x81, 0xFF,
    0xCF, 0xCF, 0xCF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xF3, 0xE7, 0xCF, 0xCF, 0xCF, 0xE7, 0xF3, 0xFF,
    0x9F, 0xCF, 0xE7, 0xE7, 0xE7, 0xCF, 0x9F, 0xFF,
    0xFF, 0x93, 0xC7, 0x01, 0xC7, 0x93, 0xFF, 0xFF,
    0xFF, 0xE7, 0xE7, 0x81, 0xE7, 0xE7, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xCF, 0xCF, 0x9F,
    0xFF, 0xFF, 0xFF, 0x81, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xCF, 0xCF, 0xFF,
    0xFD, 0xFB, 0xF7, 0xEF, 0xDF, 0xBF, 0x7F, 0xFF,
    0xC7, 0xB3, 0x39, 0x39, 0x39, 0x9B, 0xC7, 0xFF,
    0xE7, 0xC7, 0xE7, 0xE7, 0xE7, 0xE7, 0x81, 0xFF,
    0x83, 0x39, 0xF1, 0xC3, 0x87, 0x1F, 0x01, 0xFF,
    0x81, 0xF3, 0xE7, 0xC3, 0xF9, 0x39, 0x83, 0xFF,
    0xE3, 0xC3, 0x93, 0x33, 0x01, 0xF3, 0xF3, 0xFF,
    0x03, 0x3F, 0x03, 0xF9, 0xF9, 0x39, 0x83, 0xFF,
    0xC3, 0x9F, 0x3F, 0x03, 0x39, 0x39, 0x83, 0xFF,
    0x01, 0x39, 0xF3, 0xE7, 0xCF, 0xCF, 0xCF, 0xFF,
    0x87, 0x3B, 0x1B, 0x87, 0x61, 0x79, 0x83, 0xFF,
    0x83, 0x39, 0x39, 0x81, 0xF9, 0xF3, 0x87, 0xFF,
    0xFF, 0xCF, 0xCF, 0xFF, 0xCF, 0xCF, 0xFF, 0xFF,
    0xFF, 0xCF, 0xCF, 0xFF, 0xCF, 0xCF, 0x9F, 0xFF,
    0xF3, 0xE7, 0xCF, 0x9F, 0xCF, 0xE7, 0xF3, 0xFF,
    0xFF, 0xFF, 0x01, 0xFF, 0x01, 0xFF, 0xFF, 0xFF,
    0x9F, 0xCF, 0xE7, 0xF3, 0xE7, 0xCF, 0x9F, 0xFF,
    0x83, 0x01, 0x39, 0xF3, 0xC7, 0xFF, 0xC7, 0xFF,
    0x83, 0x7D, 0x45, 0x55, 0x41, 0x7F, 0x83, 0xFF,
    0xC7, 0x93, 0x39, 0x39, 0x01, 0x39, 0x39, 0xFF,
    0x03, 0x39, 0x39, 0x03, 0x39, 0x39, 0x03, 0xFF,
    0xC3, 0x99, 0x3F, 0x3F, 0x3F, 0x99, 0xC3, 0xFF,
    0x07, 0x33, 0x39, 0x39, 0x39, 0x33, 0x07, 0xFF,
    0x01, 0x3F, 0x3F, 0x03, 0x3F, 0x3F, 0x01, 0xFF,
    0x01, 0x3F, 0x3F, 0x03, 0x3F, 0x3F, 0x3F, 0xFF,
    0xC1, 0x9F, 0x3F, 0x31, 0x39, 0x99, 0xC1, 0xFF,
    0x39, 0x39, 0x39, 0x01, 0x39, 0x39, 0x39, 0xFF,
    0x81, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0x81, 0xFF,
    0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0x39, 0x83, 0xFF,
    0x39, 0x33, 0x27, 0x0F, 0x07, 0x23, 0x31, 0xFF,
    0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x81, 0xFF,
    0x39, 0x11, 0x01, 0x01, 0x29, 0x39, 0x39, 0xFF,
    0x39, 0x19, 0x09, 0x01, 0x21, 0x31, 0x39, 0xFF,
    0x83, 0x39, 0x39, 0x39, 0x39, 0x39, 0x83, 0xFF,
    0x03, 0x39, 0x39, 0x39, 0x03, 0x3F, 0x3F, 0xFF,
    0x83, 0x39, 0x39, 0x39, 0x21, 0x33, 0x85, 0xFF,
    0x03, 0x39, 0x39, 0x31, 0x07, 0x23, 0x31, 0xFF,
    0x87, 0x33, 0x3F, 0x83, 0xF9, 0x39, 0x83, 0xFF,
    0x81, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xFF,
    0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x83, 0xFF,
    0x39, 0x39, 0x39, 0x11, 0x83, 0xC7, 0xEF, 0xFF,
    0x39, 0x39, 0x29, 0x01, 0x01, 0x11, 0x39, 0xFF,
    0x39, 0x11, 0x83, 0xC7, 0x83, 0x11, 0x39, 0xFF,
    0x99, 0x99, 0x99, 0xC3, 0xE7, 0xE7, 0xE7, 0xFF,
    0x01, 0xF1, 0xE3, 0xC7, 0x8F, 0x1F, 0x01, 0xFF,
    0xC3, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xC3, 0xFF,
    0x7F, 0xBF, 0xDF, 0xEF, 0xF7, 0xFB, 0xFD, 0xFF,
    0x87, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0x87, 0xFF,
    0xC7, 0x93, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01,
    0xEF, 0xF7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0x83, 0xF9, 0x81, 0x39, 0x81, 0xFF,
    0x3F, 0x3F, 0x03, 0x39, 0x39, 0x39, 0x83, 0xFF,
    0xFF, 0xFF, 0x81, 0x3F, 0x3F, 0x3F, 0x81, 0xFF,
    0xF9, 0xF9, 0x81, 0x39, 0x39, 0x39, 0x81, 0xFF,
    0xFF, 0xFF, 0x83, 0x39, 0x01, 0x3F, 0x83, 0xFF,
    0xF1, 0xE7, 0x81, 0xE7, 0xE7, 0xE7, 0xE7, 0xFF,
    0xFF, 0xFF, 0x81, 0x39, 0x39, 0x81, 0xF9, 0x83,
    0x3F, 0x3F, 0x03, 0x39, 0x39, 0x39, 0x39, 0xFF,
    0xE7, 0xFF, 0xC7, 0xE7, 0xE7, 0xE7, 0x81, 0xFF,
    0xF3, 0xFF, 0xE3, 0xF3, 0xF3, 0xF3, 0xF3, 0x87,
    0x3F, 0x3F, 0x31, 0x03, 0x07, 0x23, 0x31, 0xFF,
    0xC7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0x81, 0xFF,
    0xFF, 0xFF, 0x03, 0x49, 0x49, 0x49, 0x49, 0xFF,
    0xFF, 0xFF, 0x03, 0x39, 0x39, 0x39, 0x39, 0xFF,
    0xFF, 0xFF, 0x83, 0x39, 0x39, 0x39, 0x83, 0xFF,
    0xFF, 0xFF, 0x03, 0x39, 0x39, 0x03, 0x3F, 0x3F,
    0xFF, 0xFF, 0x81, 0x39, 0x39, 0x81, 0xF9, 0xF9,
    0xFF, 0xFF, 0x91, 0x8F, 0x9F, 0x9F, 0x9F, 0xFF,
    0xFF, 0xFF, 0x83, 0x3F, 0x83, 0xF9, 0x03, 0xFF,
    0xE7, 0xE7, 0x81, 0xE7, 0xE7, 0xE7, 0xE7, 0xFF,
    0xFF, 0xFF, 0x39, 0x39, 0x39, 0x39, 0x81, 0xFF,
    0xFF, 0xFF, 0x99, 0x99, 0x99, 0xC3, 0xE7, 0xFF,
    0xFF, 0xFF, 0x49, 0x49, 0x49, 0x49, 0x81, 0xFF,
    0xFF, 0xFF, 0x39, 0x01, 0xC7, 0x01, 0x39, 0xFF,
    0xFF, 0xFF, 0x39, 0x39, 0x39, 0x81, 0xF9, 0x83,
    0xFF, 0xFF, 0x01, 0xE3, 0xC7, 0x8F, 0x01, 0xFF,
    0xF3, 0xE7, 0xE7, 0xCF, 0xE7, 0xE7, 0xF3, 0xFF,
    0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xFF,
    0x9F, 0xCF, 0xCF, 0xE7, 0xCF, 0xCF, 0x9F, 0xFF,
    0xFF, 0xFF, 0x8F, 0x45, 0xE3, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x93, 0x93, 0xFF,
    0x83, 0x11, 0x29, 0x39, 0x29, 0x29, 0x83, 0xFF,
    0x83, 0x31, 0x29, 0x31, 0x29, 0x31, 0x83, 0xFF,
    0x83, 0x11, 0x11, 0x7D, 0x11, 0x11, 0x83, 0xFF,
    0x83, 0x01, 0x01, 0x7D, 0x01, 0x01, 0x83, 0xFF,
    0x83, 0x11, 0x21, 0x7D, 0x21, 0x11, 0x83, 0xFF,
    0x83, 0x11, 0x09, 0x7D, 0x09, 0x11, 0x83, 0xFF,
    0x83, 0x11, 0x39, 0x55, 0x11, 0x11, 0x83, 0xFF,
    0x83, 0x11, 0x11, 0x55, 0x39, 0x11, 0x83, 0xFF,
    0x83, 0x11, 0x39, 0x7D, 0x39, 0x11, 0x83, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xE7, 0xFF, 0xE7, 0xE7, 0xC7, 0xC7, 0xC7, 0xFF,
    0xEF, 0x83, 0x29, 0x2F, 0x29, 0x83, 0xEF, 0xFF,
    0xC3, 0x99, 0x9F, 0x03, 0x9F, 0x9F, 0x01, 0xFF,
    0xFF, 0xA5, 0xDB, 0xDB, 0xDB, 0xA5, 0xFF, 0xFF,
    0x99, 0x99, 0xC3, 0x81, 0xE7, 0x81, 0xE7, 0xFF,
    0xE7, 0xE7, 0xE7, 0xFF, 0xE7, 0xE7, 0xE7, 0xFF,
    0xC3, 0x99, 0x87, 0xDB, 0xE1, 0x99, 0xC3, 0xFF,
    0x93, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xC3, 0xBD, 0x66, 0x5E, 0x5E, 0x66, 0xBD, 0xC3,
    0x87, 0xC3, 0x93, 0xC3, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xC9, 0x93, 0x27, 0x93, 0xC9, 0xFF, 0xFF,
    0xFF, 0xFF, 0x81, 0xF9, 0xF9, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xC3, 0xBD, 0x46, 0x5A, 0x46, 0x5A, 0xBD, 0xC3,
    0x83, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xEF, 0xD7, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xE7, 0xE7, 0x81, 0xE7, 0xE7, 0xFF, 0x81, 0xFF,
    0xC7, 0xF3, 0xE7, 0xC3, 0xFF, 0xFF, 0xFF, 0xFF,
    0xC3, 0xE7, 0xF3, 0xC7, 0xFF, 0xFF, 0xFF, 0xFF,
    0xF7, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0x33, 0x33, 0x33, 0x33, 0x09, 0x3F,
    0xC1, 0x95, 0xB5, 0x95, 0xC1, 0xF5, 0xF5, 0xFF,
    0xFF, 0xFF, 0xFF, 0xCF, 0xCF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0xCF,
    0xE7, 0xC7, 0xE7, 0xC3, 0xFF, 0xFF, 0xFF, 0xFF,
    0xC7, 0x93, 0x93, 0xC7, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0x27, 0x93, 0xC9, 0x93, 0x27, 0xFF, 0xFF,
    0xBD, 0x3B, 0xB7, 0xAD, 0xD9, 0xB1, 0x7D, 0xFF,
    0xBD, 0x3B, 0xB7, 0xA9, 0xDD, 0xBB, 0x71, 0xFF,
    0x1D, 0xBB, 0xD7, 0x2D, 0xD9, 0xB1, 0x7D, 0xFF,
    0xC7, 0xFF, 0xC7, 0x9F, 0x39, 0x01, 0x83, 0xFF,
    0xDF, 0xEF, 0xC7, 0x93, 0x39, 0x01, 0x39, 0xFF,
    0xF7, 0xEF, 0xC7, 0x93, 0x39, 0x01, 0x39, 0xFF,
    0xC7, 0x93, 0xC7, 0x93, 0x39, 0x01, 0x39, 0xFF,
    0xCB, 0xA7, 0xC7, 0x93, 0x39, 0x01, 0x39, 0xFF,
    0x93, 0xFF, 0xC7, 0x93, 0x39, 0x01, 0x39, 0xFF,
    0xEF, 0xD7, 0xC7, 0x93, 0x39, 0x01, 0x39, 0xFF,
    0xC1, 0x87, 0x27, 0x21, 0x07, 0x27, 0x21, 0xFF,
    0xC3, 0x99, 0x3F, 0x3F, 0x99, 0xC3, 0xF7, 0xCF,
    0xDF, 0xEF, 0x01, 0x3F, 0x03, 0x3F, 0x01, 0xFF,
    0xF7, 0xEF, 0x01, 0x3F, 0x03, 0x3F, 0x01, 0xFF,
    0xC7, 0x93, 0x01, 0x3F, 0x03, 0x3F, 0x01, 0xFF,
    0x93, 0xFF, 0x01, 0x3F, 0x03, 0x3F, 0x01, 0xFF,
    0xEF, 0xF7, 0x81, 0xE7, 0xE7, 0xE7, 0x81, 0xFF,
    0xF7, 0xEF, 0x81, 0xE7, 0xE7, 0xE7, 0x81, 0xFF,
    0xE7, 0xC3, 0x81, 0xE7, 0xE7, 0xE7, 0x81, 0xFF,
    0x99, 0xFF, 0x81, 0xE7, 0xE7, 0xE7, 0x81, 0xFF,
    0x87, 0x93, 0x99, 0x09, 0x99, 0x93, 0x87, 0xFF,
    0xCB, 0xA7, 0x19, 0x09, 0x01, 0x21, 0x31, 0xFF,
    0xDF, 0xEF, 0x83, 0x39, 0x39, 0x39, 0x83, 0xFF,
    0xF7, 0xEF, 0x83, 0x39, 0x39, 0x39, 0x83, 0xFF,
    0xC7, 0x93, 0x83, 0x39, 0x39, 0x39, 0x83, 0xFF,
    0xCB, 0xA7, 0x83, 0x39, 0x39, 0x39, 0x83, 0xFF,
    0x93, 0xFF, 0x83, 0x39, 0x39, 0x39, 0x83, 0xFF,
    0xFF, 0xBB, 0xD7, 0xEF, 0xD7, 0xBB, 0xFF, 0xFF,
    0x83, 0x39, 0x31, 0x29, 0x19, 0x39, 0x83, 0xFF,
    0xDF, 0xEF, 0x39, 0x39, 0x39, 0x39, 0x83, 0xFF,
    0xF7, 0xEF, 0x39, 0x39, 0x39, 0x39, 0x83, 0xFF,
    0xC7, 0x93, 0xFF, 0x39, 0x39, 0x39, 0x83, 0xFF,
    0x93, 0xFF, 0x39, 0x39, 0x39, 0x39, 0x83, 0xFF,
    0xF7, 0xEF, 0x99, 0x99, 0xC3, 0xE7, 0xE7, 0xFF,
    0x3F, 0x03, 0x39, 0x39, 0x39, 0x03, 0x3F, 0xFF,
    0xC3, 0x99, 0x99, 0x93, 0x99, 0x89, 0x93, 0xFF,
    0xDF, 0xEF, 0x83, 0xF9, 0x81, 0x39, 0x81, 0xFF,
    0xF7, 0xEF, 0x83, 0xF9, 0x81, 0x39, 0x81, 0xFF,
    0xC7, 0x93, 0x83, 0xF9, 0x81, 0x39, 0x81, 0xFF,
    0xCB, 0xA7, 0x83, 0xF9, 0x81, 0x39, 0x81, 0xFF,
    0x93, 0xFF, 0x83, 0xF9, 0x81, 0x39, 0x81, 0xFF,
    0xEF, 0xD7, 0x83, 0xF9, 0x81, 0x39, 0x81, 0xFF,
    0xFF, 0xFF, 0x83, 0xE9, 0x81, 0x2F, 0x83, 0xFF,
    0xFF, 0xFF, 0x81, 0x3F, 0x3F, 0x81, 0xF7, 0xCF,
    0xDF, 0xEF, 0x83, 0x39, 0x01, 0x3F, 0x83, 0xFF,
    0xF7, 0xEF, 0x83, 0x39, 0x01, 0x3F, 0x83, 0xFF,
    0xC7, 0x93, 0x83, 0x39, 0x01, 0x3F, 0x83, 0xFF,
    0x93, 0xFF, 0x83, 0x39, 0x01, 0x3F, 0x83, 0xFF,
    0xDF, 0xEF, 0xFF, 0xC7, 0xE7, 0xE7, 0x81, 0xFF,
    0xF7, 0xEF, 0xFF, 0xC7, 0xE7, 0xE7, 0x81, 0xFF,
    0xC7, 0x93, 0xFF, 0xC7, 0xE7, 0xE7, 0x81, 0xFF,
    0x93, 0xFF, 0xC7, 0xE7, 0xE7, 0xE7, 0x81, 0xFF,
    0x9B, 0x87, 0x67, 0x83, 0x39, 0x39, 0x83, 0xFF,
    0xCB, 0xA7, 0x03, 0x39, 0x39, 0x39, 0x39, 0xFF,
    0xDF, 0xEF, 0x83, 0x39, 0x39, 0x39, 0x83, 0xFF,
    0xF7, 0xEF, 0x83, 0x39, 0x39, 0x39, 0x83, 0xFF,
    0xC7, 0x93, 0x83, 0x39, 0x39, 0x39, 0x83, 0xFF,
    0xCB, 0xA7, 0x83, 0x39, 0x39, 0x39, 0x83, 0xFF,
    0x93, 0xFF, 0x83, 0x39, 0x39, 0x39, 0x83, 0xFF,
    0xFF, 0xE7, 0xFF, 0x81, 0xFF, 0xE7, 0xFF, 0xFF,
    0xFF, 0xFF, 0x83, 0x31, 0x29, 0x19, 0x83, 0xFF,
    0xDF, 0xEF, 0x39, 0x39, 0x39, 0x39, 0x81, 0xFF,
    0xF7, 0xEF, 0x39, 0x39, 0x39, 0x39, 0x81, 0xFF,
    0xC7, 0x93, 0xFF, 0x39, 0x39, 0x39, 0x81, 0xFF,
    0x93, 0xFF, 0x39, 0x39, 0x39, 0x39, 0x81, 0xFF,
    0xF7, 0xEF, 0x39, 0x39, 0x39, 0x81, 0xF9, 0x83,
    0x3F, 0x3F, 0x03, 0x39, 0x39, 0x03, 0x3F, 0x3F,
    0x93, 0xFF, 0x39, 0x39, 0x39, 0x81, 0xF9, 0x83,
};

fn text(
    str_ptr: [*]const User(u8),
    str_len: usize,
    x: i32,
    rest: *const extern struct {
        y: User(i32),
        text_color: User(api.DisplayColor.Optional),
        background_color: User(api.DisplayColor.Optional),
    },
) callconv(.C) void {
    const str = str_ptr[0..str_len];
    _ = str; // autofix
    var y = rest.y.load();
    const text_color = rest.text_color.load();
    const background_color = rest.background_color.load();

    var current_x = x;
    for ("abc") |c| {
        // const char = c.load();
        const char = c;
        if (char == 10) {
            y += 8;
            current_x = x;
        } else if (char >= 32 and char <= 255) {
            blitPalette(&.{ text_color, background_color }, &font, current_x, y, 8, 8, 0, (char - 32) << 3, 8, false, false, false);
            current_x += 8;
        } else {
            current_x += 8;
        }
    }
}

fn blitPalette(
    colors: []const api.DisplayColor.Optional,
    sprite: []const u8,
    dst_x: i32,
    dst_y: i32,
    width: u32,
    height: u32,
    src_x: u32,
    src_y: u32,
    src_stride: u32,
    flip_x: bool,
    flip_y: bool,
    rotate: bool,
) void {
    // Clip rectangle to screen
    var clip_x_min: u32 = 0;
    var clip_y_min: u32 = 0;
    var clip_x_max: u32 = 0;
    var clip_y_max: u32 = 0;

    var real_flip_x = flip_x;

    if (rotate) {
        real_flip_x = !flip_x;
        clip_x_min = @intCast(@max(0, dst_y) - dst_y);
        clip_y_min = @intCast(@max(0, dst_x) - dst_x);
        clip_x_max = @intCast(@min(@as(i32, @intCast(width)), @as(i32, @intCast(api.screen_height)) - dst_y));
        clip_y_max = @intCast(@min(@as(i32, @intCast(height)), @as(i32, @intCast(api.screen_width)) - dst_x));
    } else {
        clip_x_min = @intCast(@max(0, dst_x) - dst_x);
        clip_y_min = @intCast(@max(0, dst_y) - dst_y);
        clip_x_max = @intCast(@min(@as(i32, @intCast(width)), @as(i32, @intCast(api.screen_width)) - dst_x));
        clip_y_max = @intCast(@min(@as(i32, @intCast(height)), @as(i32, @intCast(api.screen_height)) - dst_y));
    }

    // Iterate pixels in rectangle
    for (clip_y_min..clip_y_max) |yu| {
        for (clip_x_min..clip_x_max) |xu| {
            const y: i32 = @intCast(yu);
            const x: i32 = @intCast(xu);

            // Calculate sprite target coords
            const tx = dst_x + if (rotate) y else x;
            const ty = dst_y + if (rotate) x else y;

            // Calculate sprite source coords
            const sx = @as(i32, @intCast(src_x)) + if (flip_x) @as(i32, @intCast(width)) - x - 1 else x;
            const sy = @as(i32, @intCast(src_y)) + if (flip_y) @as(i32, @intCast(height)) - y - 1 else y;

            // Sample the sprite to get a color index
            var color_idx: usize = 0;
            const bit_index: usize = @intCast(sy * @as(i32, @intCast(src_stride)) + sx);

            if (colors.len == 4) {
                const byte = sprite[bit_index >> 2];
                const shift = 6 - ((bit_index & 0x03) << 1);
                color_idx = (byte >> @intCast(shift)) & 0b11;
            } else {
                const byte = sprite[bit_index >> 3];
                const shift = 7 - (bit_index & 0x7);
                color_idx = (byte >> @intCast(shift)) & 0b1;
            }

            if (colors[color_idx].unwrap()) |color| {
                api.framebuffer[@intCast(ty * api.screen_width + tx)] = color;
            }
        }
    }
}

fn hline(
    x: i32,
    y: i32,
    len: u32,
    color: api.DisplayColor,
) callconv(.C) void {
    if (y < 0 or y >= api.screen_height) return;

    const y_offset = api.screen_width * @as(u32, @intCast(y));
    @memset(api.framebuffer[y_offset + @as(u32, @intCast(std.math.clamp(x, 0, @as(i32, @intCast(api.screen_width))))) ..][0..len], color);
}

fn vline(
    x: i32,
    y: i32,
    len: u32,
    color: api.DisplayColor,
) callconv(.C) void {
    if (y + @as(i32, @intCast(len)) <= 0 or x < 0 or x >= @as(i32, @intCast(api.screen_width))) return;

    const start_y: u32 = @intCast(@max(0, y));
    const end_y: u32 = @intCast(@min(api.screen_height, y + @as(i32, @intCast(len))));

    for (start_y..end_y) |yy| {
        api.framebuffer[api.screen_width * yy + @as(u32, @intCast(x))] = color;
    }
}

fn tone(
    frequency: u32,
    duration: u32,
    volume: u32,
    flags: api.ToneOptions.Flags,
) callconv(.C) void {
    const start_frequency: u16 = @truncate(frequency >> 0);
    const end_frequency = switch (@as(u16, @truncate(frequency >> 16))) {
        0 => start_frequency,
        else => |end_frequency| end_frequency,
    };
    const sustain_time: u8 = @truncate(duration >> 0);
    const release_time: u8 = @truncate(duration >> 8);
    const decay_time: u8 = @truncate(duration >> 16);
    const attack_time: u8 = @truncate(duration >> 24);
    const total_time = @as(u10, attack_time) + decay_time + sustain_time + release_time;
    const sustain_volume: u8 = @truncate(volume >> 0);
    const peak_volume = switch (@as(u8, @truncate(volume >> 8))) {
        0 => 100,
        else => |attack_volume| attack_volume,
    };

    var state: audio.Channel = .{
        .duty = 0,
        .phase = 0,
        .phase_step = 0,
        .phase_step_step = 0,

        .duration = 0,
        .attack_duration = 0,
        .decay_duration = 0,
        .sustain_duration = 0,
        .release_duration = 0,

        .volume = 0,
        .volume_step = 0,
        .peak_volume = 0,
        .sustain_volume = 0,
        .attack_volume_step = 0,
        .decay_volume_step = 0,
        .release_volume_step = 0,
    };

    const start_phase_step = @mulWithOverflow((1 << 32) / 44100, @as(u31, start_frequency));
    const end_phase_step = @mulWithOverflow((1 << 32) / 44100, @as(u31, end_frequency));
    if (start_phase_step[1] != 0 or end_phase_step[1] != 0) return;
    state.phase_step = start_phase_step[0];
    state.phase_step_step = @divTrunc(@as(i32, end_phase_step[0]) - start_phase_step[0], @as(u20, total_time) * @divExact(44100, 60));

    state.attack_duration = @as(u18, attack_time) * @divExact(44100, 60);
    state.decay_duration = @as(u18, decay_time) * @divExact(44100, 60);
    state.sustain_duration = @as(u18, sustain_time) * @divExact(44100, 60);
    state.release_duration = @as(u18, release_time) * @divExact(44100, 60);

    state.peak_volume = @as(u29, peak_volume) << 21;
    state.sustain_volume = @as(u29, sustain_volume) << 21;
    if (state.attack_duration > 0) {
        state.attack_volume_step = @divTrunc(@as(i32, state.peak_volume) - 0, state.attack_duration);
    }
    if (state.decay_duration > 0) {
        state.decay_volume_step = @divTrunc(@as(i32, state.sustain_volume) - state.peak_volume, state.decay_duration);
    }
    if (state.release_duration > 0) {
        state.release_volume_step = @divTrunc(@as(i32, 0) - state.sustain_volume, state.release_duration);
    }

    switch (flags.channel) {
        .pulse1, .pulse2 => {
            state.duty = switch (flags.duty_cycle) {
                .@"1/8" => (1 << 32) / 8,
                .@"1/4" => (1 << 32) / 4,
                .@"1/2" => (1 << 32) / 2,
                .@"3/4" => (3 << 32) / 4,
            };
        },
        .triangle => {
            state.duty = (1 << 32) / 2;
        },
        .noise => {
            state.duty = (1 << 32) / 2;
        },
    }

    audio.set_channel(@intFromEnum(flags.channel), state);
}

fn read_flash(
    offset: u32,
    dst_ptr: [*]User(u8),
    dst_len: usize,
) callconv(.C) u32 {
    const dst = dst_ptr[0..dst_len];

    _ = offset;
    _ = dst;

    return 0;
}

fn write_flash_page(
    page: u16,
    src: *const [api.flash_page_size]User(u8),
) callconv(.C) void {
    _ = page;
    _ = src;
}

fn trace(
    str_ptr: [*]const User(u8),
    str_len: usize,
) callconv(.C) void {
    const str = str_ptr[0..str_len];

    _ = str;
}
