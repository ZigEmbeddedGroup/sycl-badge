//! Clock Management
//!
//! After Reset:
//!
//! On any Reset the synchronous clocks start to their initial state:
//!
//! • DFLL48M is enabled and configured to run at 48MHz
//! • Generic Generator 0 uses DFLL48M as source and generates GCLK_MAIN
//! • CPU and BUS clocks are undivided
//!
//! On a Power-on Reset, the 32KHz clock sources are reset and the GCLK module
//! starts to its initial state:
//!
//! • All Generic Clock Generators are disabled except
//!   – Generator 0 is using DFLL48M at 48MHz as source and generates GCLK_MAIN
//! • All Peripheral Channels in GCLK are disabled.
//!
//! On a User Reset the GCLK module starts to its initial state, except for:
//!
//! • Generic Clocks that are write-locked, i.e., the according WRTLOCK is set
//!   to 1 prior to Reset
//!
//! First items to implement:
//! - enable CLK_USB_AHB in main clock module (MCLK)
//!   - note defaul state in `Peripheral Clock Masking`
//! - GCLK_USB clocking the USB, configured in the Generic Clock Controller.
//! - GCLK_USB must be 48 MHz
//! - GCLK_USB_AHB must be minimum 8 MHz.
//! - GCLK_USB is generated by DFLL48 using a reference clock.
//!
//!
//! GCLK
//! ====
//!
//! The GCLK module is comprised of twelve generic clock generators, sourcing up
//! to 48 peripheral channels and the main clock signal.
//!
//! A clock source selected as an input to a generator can either be used
//! directly, or it can be prescaled in the generator.
//!
//!
//! Initialization
//!
//! Before a generator is enabled, the corresponding clock source should be
//! enabled. The Peripheral clock must be configured as outlined by the
//! following steps:
//!
//! 1. The generator must be enabled (GENCTRLn.GENEN=1) and the division factor
//!    must be set (GENTRLn.DIVSEL and GENCTRLn.DIV) by performing a single
//!    32-bit write to the generator control register (GENCTRLn)
//!
//! 2. The Generic clock for a peripheral must be configured by writing to the
//!    peripheral channel control register (PCHCTRLm) belonging to the
//!    peripheral. The generator used as the source for the peripheral clock
//!    must be written to the GEN bit field.
//!
//! Note: Each Generator n is configured by one dedicated register GENCTRLn
//! Note: Each Peripheral Channel m is configured by one dedicated register
//!       PCHCTRLm.
//!
//!
//! Enabling, Disabling, and Resetting
//!
//! The GCLK module has no enabled/disable bit to enable or disable the whole
//! module.
//!
//! The GCLK is reset by setting the Software Reset bit in the control A
//! register to 1. All registers in the GCLK will be reset to their initial
//! state, except for peripheral channels and associated generators who are
//! locked.
//!
const std = @import("std");
const microzig = @import("microzig");
const OSCCTRL = microzig.chip.peripherals.OSCCTRL;
const OSC32KCTRL = microzig.chip.peripherals.OSC32KCTRL;

pub const mclk = @import("clocks/mclk.zig");
pub const gclk = @import("clocks/gclk.zig");
pub const oscctrl = @import("clocks/oscctrl.zig");

pub const Frequencies = struct {
    oscillators: struct {
        DFLL48M: u32,
        FDPLL: [2]u32,
    },
    generators: [12]u32,
    peripherals: Peripherals,
    gclk_main: u32,

    pub fn get(state: State) Frequencies {
        return Frequencies{
            .oscillators = .{
                .DFLL48M = if (state.oscillators_controller.frequency_locked_loop.enabled)
                    48_000_000
                else
                    0,
                .FDPLL = .{
                    state.oscillators_controller.phase_locked_loop[0].get_output_freq_hz(),
                    state.oscillators_controller.phase_locked_loop[1].get_output_freq_hz(),
                },
            },
            .generators = blk: {
                var ret: [12]u32 = undefined;
                for (&ret, state.generic_clock_controller.generators) |*r, g|
                    r.* = g.get_output_freq_hz();

                break :blk ret;
            },
            .peripherals = blk: {
                var ret: Peripherals = undefined;
                ret.slow = .{
                    .OSCCTRL_FDPLL0_32K = 0,
                };

                ret.EVSYS = .{0} ** 12;

                inline for (@typeInfo(Peripherals).Struct.fields) |field| {
                    if (@typeInfo(field.type) != .Int)
                        break;

                    @field(ret, field.name) = get_peripheral_clock_freq_hz(@field(gclk.PeripheralIndex, "GCLK_" ++ field.name));
                }
                break :blk ret;
            },
            .gclk_main = state.generic_clock_controller.generators[0].get_output_freq_hz(),
        };
    }

    pub const Peripherals = struct {
        OSCCTRL_DFLL48: u32,
        OSCCTRL_FDPLL0: u32,
        OSCCTRL_FDPLL1: u32,
        slow: union {
            OSCCTRL_FDPLL0_32K: u32,
            OSCCTRL_FDPLL1_32K: u32,
            SDHC0_SLOW: u32,
            SDHC1_SLOW: u32,
            SERCOM_0_TO_7: u32,
        },
        EIC: u32,
        FREQM_MSR: u32,
        FREQM_REF: u32,
        SERCOM0_CORE: u32,
        SERCOM1_CORE: u32,
        TC0_TC1: u32,
        USB: u32,
        EVSYS: [12]u32,
        SERCOM2_CORE: u32,
        SERCOM3_CORE: u32,
        TCC0_TCC1: u32,
        TC2_TC3: u32,
        CAN0: u32,
        CAN1: u32,
        TCC2_TCC3: u32,
        TC4_TC5: u32,
        PDEC: u32,
        AC: u32,
        CCL: u32,
        SERCOM4_CORE: u32,
        SERCOM5_CORE: u32,
        SERCOM6_CORE: u32,
        SERCOM7_CORE: u32,
        TCC4: u32,
        TC6_TC7: u32,
        ADC0: u32,
        ADC1: u32,
        DAC: u32,
        I2S: u32,
        SDHC0: u32,
        SDHC1: u32,
        CM4_TRACE: u32,
    };
};

pub const State = struct {
    oscillators_controller: struct {
        /// 48 MHz output
        frequency_locked_loop: struct {
            enabled: bool,
            on_demand_enabled: bool,
            operating_mode: enum {
                open_loop,
                closed_loop,
            },
            // TODO: other info that I'm not sure is interesting
        },
        xosc: [2]Xosc,
        /// 96 - 200 MHz
        ///
        /// 32kHz - 3.2MHz
        phase_locked_loop: [2]PhaseLockedLoop,
        rtc: struct {
            clock_selection: microzig.chip.types.peripherals.OSC32KCTRL.OSC32KCTRL_RTCCTRL__RTCSEL,
        },
        xosc32k: struct {
            enabled: bool,
            crystal_oscillator_enabled: bool,
            on_demand_enabled: bool,
            enabled_32khz: bool,
            enabled_1khz: bool,
        },
        /// Ultra Low-Power Internal Oscillator
        osculp32k: struct {
            enabled_32khz: bool,
            enabled_1khz: bool,
        },
    },
    generic_clock_controller: struct {
        generators: [12]Generator,
        peripherals: Peripherals,
    },
    main_clock_controller: struct {
        hsdiv: mclk.HsDiv,
        cpudiv: mclk.CpuDiv,
        ahb_mask: mclk.AhbMask,
        apb_mask: mclk.ApbMask,
    },

    pub const Generator = struct {
        enabled: bool,
        source: gclk.Source,
        div: u16,
        div_selection: gclk.DivSelection,
        output_enable: bool,
        output_off_value: enum {
            low,
            high,
        },
        improve_duty_cycle: enum {
            not_balanced,
            balanced_50_50,
        },

        pub fn get_div(generator: Generator) u32 {
            return switch (generator.div_selection) {
                .DIV1 => if (generator.div <= 1) 1 else generator.div,
                .DIV2 => std.math.pow(u32, 2, generator.div + 1),
            };
        }

        pub fn get_output_freq_hz(generator: Generator) u32 {
            if (!generator.enabled)
                return 0;

            const div = generator.get_div();
            return switch (generator.source) {
                .XOSC0, .XOSC1 => @panic("TODO"),
                .GCLKIN => @panic("TODO"),
                .GCLKGEN1 => blk: {
                    const gen1 = get_generator(1);
                    break :blk gen1.get_output_freq_hz();
                },
                .OSCULP32K => @panic("TODO"),
                .XOSC32K => @panic("TODO"),
                .DFLL => 48_000_000,
                .DPLL0, .DPLL1 => blk: {
                    const index: u1 = switch (generator.source) {
                        .DPLL0 => 0,
                        .DPLL1 => 1,
                        else => unreachable,
                    };

                    const pll = get_phase_locked_loop(index);
                    break :blk pll.get_output_freq_hz();
                },
                _ => unreachable,
            } / div;
        }
    };

    pub const Xosc = struct {
        enabled: bool,
        on_demand_enabled: bool,
        crystal_oscillator_enabled: bool,
        switch_back_enabled: bool,
        clock_failure_detector_enabled: bool,
        automatic_control_loop_enabled: bool,
        low_buffer_gain_enabled: bool,
    };

    pub const PhaseLockedLoop = struct {
        index: u1,
        enabled: bool,
        on_demand_enabled: bool,
        frac: u5,
        ratio: u13,
        div: u11,
        ref_clk: microzig.chip.types.peripherals.OSCCTRL.OSCCTRL_DPLLCTRLB__REFCLK,

        pub fn get_output_freq_hz(pll: PhaseLockedLoop) u32 {
            if (!pll.enabled)
                return 0;

            return switch (pll.ref_clk) {
                .GCLK => blk: {
                    const index: gclk.PeripheralIndex = switch (pll.index) {
                        0 => .GCLK_OSCCTRL_FDPLL0,
                        1 => .GCLK_OSCCTRL_FDPLL1,
                    };

                    break :blk get_peripheral_clock_freq_hz(index);
                },
                .XOSC32 => 32_000,
                .XOSC0 => @panic("TODO"),
                .XOSC1 => @panic("TODO"),
                _ => unreachable,
            } * (pll.ratio + 1
            //+ (pll.frac / 32)
            );
        }
    };

    pub const Peripheral = struct {
        channel_enable: bool,
        write_locked: bool,
        generator: gclk.Generator,
    };
    pub const Peripherals = struct {
        OSCCTRL_DFLL48: Peripheral,
        OSCCTRL_FDPLL0: Peripheral,
        OSCCTRL_FDPLL1: Peripheral,
        slow: union {
            OSCCTRL_FDPLL0_32K: Peripheral,
            OSCCTRL_FDPLL1_32K: Peripheral,
            SDHC0_SLOW: Peripheral,
            SDHC1_SLOW: Peripheral,
            SERCOM_0_TO_7: Peripheral,
        },
        EIC: Peripheral,
        FREQM_MSR: Peripheral,
        FREQM_REF: Peripheral,
        SERCOM0_CORE: Peripheral,
        SERCOM1_CORE: Peripheral,
        TC0_TC1: Peripheral,
        USB: Peripheral,
        EVSYS: [12]Peripheral,
        SERCOM2_CORE: Peripheral,
        SERCOM3_CORE: Peripheral,
        TCC0_TCC1: Peripheral,
        TC2_TC3: Peripheral,
        CAN0: Peripheral,
        CAN1: Peripheral,
        TCC2_TCC3: Peripheral,
        TC4_TC5: Peripheral,
        PDEC: Peripheral,
        AC: Peripheral,
        CCL: Peripheral,
        SERCOM4_CORE: Peripheral,
        SERCOM5_CORE: Peripheral,
        SERCOM6_CORE: Peripheral,
        SERCOM7_CORE: Peripheral,
        TCC4: Peripheral,
        TC6_TC7: Peripheral,
        ADC0: Peripheral,
        ADC1: Peripheral,
        DAC: Peripheral,
        I2S: Peripheral,
        SDHC0: Peripheral,
        SDHC1: Peripheral,
        CM4_TRACE: Peripheral,
    };
};

pub fn get_peripheral(index: u32) State.Peripheral {
    const ctrl = gclk.GCLK.PCHCTRL[index].read();
    return State.Peripheral{
        .channel_enable = ctrl.CHEN == 1,
        .write_locked = ctrl.WRTLOCK == 1,
        .generator = ctrl.GEN.value,
    };
}

pub fn get_peripheral_clock_freq_hz(index: gclk.PeripheralIndex) u32 {
    const state = get_peripheral(@intFromEnum(index));
    if (!state.channel_enable)
        return 0;

    const generator = get_generator(@intFromEnum(state.generator));
    if (!generator.enabled)
        return 0;

    return generator.get_output_freq_hz();
}

fn get_xosc(index: u32) State.Xosc {
    const ctrl = OSCCTRL.XOSCCTRL[index].read();
    return State.Xosc{
        .enabled = (ctrl.ENABLE == 1),
        .on_demand_enabled = (ctrl.ONDEMAND == 1),
        .crystal_oscillator_enabled = (ctrl.XTALEN == 1),
        .switch_back_enabled = (ctrl.SWBEN == 1),
        .clock_failure_detector_enabled = (ctrl.CFDEN == 1),
        .automatic_control_loop_enabled = (ctrl.ENALC == 1),
        .low_buffer_gain_enabled = (ctrl.LOWBUFGAIN == 1),
    };
}

fn get_phase_locked_loop(index: u1) State.PhaseLockedLoop {
    const ctrl_a = OSCCTRL.DPLL[index].DPLLCTRLA.read();
    const ctrl_b = OSCCTRL.DPLL[index].DPLLCTRLB.read();
    const ratio = OSCCTRL.DPLL[index].DPLLRATIO.read();
    return State.PhaseLockedLoop{
        .index = index,
        .enabled = (ctrl_a.ENABLE == 1),
        .on_demand_enabled = (ctrl_a.ONDEMAND == 1),
        .frac = ratio.LDRFRAC,
        .ratio = ratio.LDR,
        .div = ctrl_b.DIV,
        .ref_clk = ctrl_b.REFCLK.value,
    };
}
fn get_generator(index: u32) State.Generator {
    const ctrl = gclk.GCLK.GENCTRL[index].read();
    return State.Generator{
        .enabled = (ctrl.GENEN == 1),
        .source = ctrl.SRC.value,
        .div = ctrl.DIV,
        .div_selection = ctrl.DIVSEL.value,
        .output_enable = (ctrl.OE == 1),
        .output_off_value = @enumFromInt(ctrl.OOV),
        .improve_duty_cycle = @enumFromInt(ctrl.IDC),
    };
}

pub fn get_state() State {
    return State{
        .oscillators_controller = .{
            .frequency_locked_loop = blk: {
                const ctrl_a = OSCCTRL.DFLLCTRLA.read();
                const ctrl_b = OSCCTRL.DFLLCTRLB.read();
                break :blk .{
                    .enabled = (ctrl_a.ENABLE == 1),
                    .on_demand_enabled = (ctrl_a.ONDEMAND == 1),
                    .operating_mode = switch (ctrl_b.MODE) {
                        0 => .open_loop,
                        1 => .closed_loop,
                    },
                };
            },
            .xosc = .{
                get_xosc(0),
                get_xosc(1),
            },
            .phase_locked_loop = .{
                get_phase_locked_loop(0),
                get_phase_locked_loop(1),
            },
            .rtc = blk: {
                const ctrl = OSC32KCTRL.RTCCTRL.read();
                break :blk .{
                    .clock_selection = ctrl.RTCSEL.value,
                };
            },
            .xosc32k = blk: {
                const ctrl = OSC32KCTRL.XOSC32K.read();
                break :blk .{
                    .enabled = (ctrl.ENABLE == 1),
                    .crystal_oscillator_enabled = (ctrl.XTALEN == 1),
                    .on_demand_enabled = (ctrl.ONDEMAND == 1),
                    .enabled_32khz = (ctrl.EN32K == 1),
                    .enabled_1khz = (ctrl.EN1K == 1),
                };
            },
            .osculp32k = blk: {
                const ctrl = OSC32KCTRL.OSCULP32K.read();
                break :blk .{
                    .enabled_32khz = (ctrl.EN32K == 1),
                    .enabled_1khz = (ctrl.EN1K == 1),
                };
            },
        },
        .generic_clock_controller = .{
            .generators = blk: {
                var ret: [12]State.Generator = undefined;
                for (&ret, 0..) |*generator, i|
                    generator.* = get_generator(i);

                break :blk ret;
            },
            .peripherals = blk: {
                var ret: State.Peripherals = undefined;
                inline for (@typeInfo(State.Peripherals).Struct.fields, 0..) |field, i| {
                    if (@typeInfo(field.type) == .Union)
                        ret.slow = .{ .OSCCTRL_FDPLL0_32K = get_peripheral(i) }
                    else if (@typeInfo(field.type) == .Array) {
                        for (0..12) |j| {
                            ret.EVSYS[j] = get_peripheral(i + j);
                        }
                    } else @field(ret, field.name) = get_peripheral(i);
                }

                break :blk ret;
            },
        },
        .main_clock_controller = .{
            .hsdiv = mclk.get_hs_div(),
            .cpudiv = mclk.get_cpu_div(),
            .ahb_mask = mclk.get_ahb_mask(),
            .apb_mask = mclk.get_apb_mask(),
        },
    };
}

pub const Configuration = struct {};

pub const EnableDpllOptions = struct {
    factor: u32,
    output_freq_hz: u32,
    input_freq_hz: u32,
};

pub fn enable_dpll(index: u1, gen: gclk.Generator, comptime opts: EnableDpllOptions) void {
    const periph_index: gclk.PeripheralIndex = switch (index) {
        0 => .GCLK_OSCCTRL_FDPLL0,
        1 => .GCLK_OSCCTRL_FDPLL1,
    };

    gclk.set_peripheral_clk_gen(periph_index, gen);
    OSCCTRL.DPLL[index].DPLLCTRLB.write(.{
        .FILTER = .{ .value = .FILTER1 },
        .WUF = 0,
        .REFCLK = .{ .value = .GCLK },
        .LTIME = .{ .value = .DEFAULT },
        .LBYPASS = 0,
        .DCOFILTER = .{ .raw = 0 },
        .DCOEN = 0,
        .DIV = 0,
        .padding = 0,
    });

    const freq_hz = opts.output_freq_hz * opts.factor;
    comptime std.debug.assert(freq_hz >= 96_000_000 and freq_hz <= 200_000_000);
    const ratio = @divExact(freq_hz * 32, opts.input_freq_hz);

    OSCCTRL.DPLL[index].DPLLRATIO.write(.{
        .LDR = ratio / 32 - 1,
        .reserved16 = 0,
        .LDRFRAC = ratio % 32,
        .padding = 0,
    });
    while (OSCCTRL.DPLL[index].DPLLSYNCBUSY.read().DPLLRATIO != 0) {}

    OSCCTRL.DPLL[index].DPLLCTRLA.write(.{
        .reserved1 = 0,
        .ENABLE = 1,
        .reserved6 = 0,
        .RUNSTDBY = 0,
        .ONDEMAND = 0,
    });

    while (OSCCTRL.DPLL[index].DPLLSYNCBUSY.read().ENABLE != 0) {}
    while (OSCCTRL.DPLL[index].DPLLSTATUS.read().CLKRDY == 0) {}
}
