//! USB Controller
//!
//! Dependencies
//! ============
//!
//! I/O Lines
//!
//! The USB pins may be multiplexed with the I/O lines controller. The user
//! must first configure the I/O controller to assign the USB pins to their
//! peripheral functions.
//!
//!
//! Clocks
//!
//! The USB bus clock (CLK_USB_AHB) can be enabled and disabled in the main
//! clock module (MCLK) and the default state of CLK_USB_AHB can be found in
//! _Peripheral Clock Masking_.
//!
//! A generic clock (GCLK_USB) is required the clock the USB. This clock must be
//! configured and enabled in the Generic Clock Controller before using the USB.
//!
//! The generic clock is asynchronous to the bus clock (CLK_USB_AHB). Due to
//! this asynchronicity, writes to certain registers will require
//! synchronization between clock domains.
//!
//! The USB module requires a GCLK_USB of 48 MHz clock for low speed and full
//! speed operation. To follow the USB data rate at 12 Mbit/s in full-speed
//! mode, the CLK_USB_AHB clock should be at minimum 8MHz. THe GCLK_USB clock is
//! generated by the DFLL48 using a reference clock. When the USB is disabled,
//! the GCLK used as DFLL reference should be disabled.
//!
//! Clock recover is achieved by a digital phase-locked loop in the USB module,
//! which complies with the USB jitter specifications. If crystal-less operation
//! is used in USB device mode, refer to _USB Clock Recovery Module_.
const std = @import("std");
const microzig = @import("microzig");
const core = microzig.core;

const USB = microzig.chip.peripherals.USB;

const ENDPOINT = microzig.chip.types.peripherals.USB.ENDPOINT;
const USB_DESCRIPTOR = microzig.chip.types.peripherals.USB.USB_DESCRIPTOR;

var endpoint_buffer_storage: [8][2][64]u8 align(4) = .{.{.{0} ** 64} ** 2} ** 8;
const endpoint_buffer: *align(4) volatile [8][2][64]u8 = &endpoint_buffer_storage;

pub const Endpoint = enum(u3) {
    _,

    pub fn write(endpoint: Endpoint, data: []const u8) void {
        const buffer = &endpoint_buffer[@intFromEnum(endpoint)][1];
        @memcpy(buffer[0..data.len], data);
        microzig.cp.dmb();

        const descriptors: *volatile [8]USB_DESCRIPTOR = @ptrFromInt(USB.DEVICE.DESCADD.read().DESCADD);

        // Set buffer address for ep data
        const descriptor = &descriptors[@intFromEnum(endpoint)].DEVICE;
        descriptor.ADDR.write(.{ .ADDR = @intFromPtr(buffer) });

        // Set the byte count as zero
        // Set the multi packetsize as zero for multi-packet transfers where
        // length > ep size
        // TODO: the comment and code don't line up?
        descriptor.PCKSIZE.modify(.{
            .BYTE_COUNT = @as(u14, @intCast(data.len)),
            .MULTI_PACKET_SIZE = 0,
        });

        endpoint.clear_int_flag(.TRCPT1);
        endpoint.set_status_flag(.BLK1RDY);
        endpoint.wait_for_transfer_complete_blocking();
    }

    pub fn wait_for_transfer_complete_blocking(endpoint: Endpoint) void {
        const ctrl = endpoint.get_ctrl_regs();
        while (ctrl.EPINTFLAG.read().TRCPT1 == 0) {}
    }

    pub fn set_bank_ready(endpoint: Endpoint) void {
        endpoint.get_ctrl_regs().EPSTATUSSET.write(.{
            .DTGLOUT = 0,
            .DTGLIN = 0,
            .CURBK = 0,
            .reserved4 = 0,
            .STALLRQ0 = 0,
            .STALLRQ1 = 0,
            .BK0RDY = 0,
            .BK1RDY = 1,
        });
    }

    pub const IntFlag = enum {
        TRCPT0,
        TRCPT1,
        TRFAIL0,
        TRFAIL1,
        RXSTP,
        STALL0,
        STALL1,
    };

    pub fn clear_int_flag(endpoint: Endpoint, flag: IntFlag) void {
        endpoint.get_ctrl_regs().EPINTFLAG.write(.{
            .TRCPT0 = @intFromBool(flag == .TRCPT0),
            .TRCPT1 = @intFromBool(flag == .TRCPT1),
            .TRFAIL0 = @intFromBool(flag == .TRFAIL0),
            .TRFAIL1 = @intFromBool(flag == .TRFAIL1),
            .RXSTP = @intFromBool(flag == .RXSTP),
            .STALL0 = @intFromBool(flag == .STALL0),
            .STALL1 = @intFromBool(flag == .STALL1),
            .padding = 0,
        });
    }

    pub const StatusFlag = enum {
        DTGLOUT,
        DTGLIN,
        CURBK,
        STALLRQ0,
        STALLRQ1,
        BLK0RDY,
        BLK1RDY,
    };

    pub fn clear_status_flag(endpoint: Endpoint, flag: StatusFlag) void {
        endpoint.get_ctrl_regs().EPSTATUSCLR.write(.{
            .DTGLOUT = @intFromBool(flag == .DTGLOUT),
            .DTGLIN = @intFromBool(flag == .DTGLIN),
            .CURBK = @intFromBool(flag == .CURBK),
            .STALLRQ0 = @intFromBool(flag == .STALLRQ0),
            .STALLRQ1 = @intFromBool(flag == .STALLRQ1),
            .BLK0RDY = @intFromBool(flag == .BLK0RDY),
            .BLK1RDY = @intFromBool(flag == .BLK1RDY),
        });
    }

    pub fn set_status_flag(endpoint: Endpoint, flag: StatusFlag) void {
        endpoint.get_ctrl_regs().EPSTATUSSET.write(.{
            .DTGLOUT = @intFromBool(flag == .DTGLOUT),
            .DTGLIN = @intFromBool(flag == .DTGLIN),
            .CURBK = @intFromBool(flag == .CURBK),
            .STALLRQ0 = @intFromBool(flag == .STALLRQ0),
            .STALLRQ1 = @intFromBool(flag == .STALLRQ1),
            .BLK0RDY = @intFromBool(flag == .BLK0RDY),
            .BLK1RDY = @intFromBool(flag == .BLK1RDY),
        });
    }

    fn get_ctrl_regs(endpoint: Endpoint) *volatile ENDPOINT {
        return &USB.DEVICE.DEVICE_ENDPOINT[@intFromEnum(endpoint)];
    }
};
